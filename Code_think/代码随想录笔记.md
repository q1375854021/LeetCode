# 笔记

对应代码：写了三个排序，冒泡排序，选择排序和插入排序。



## 一、复杂度

##### 常数操作：跟数据量无关的操作

```C++
int a=a[i];					// 数组，常数操作，和数据量无关
int b=list.get(i);			// 链表遍历
// + - * / 位运算都是常数操作
```

##### 时间复杂度

时间复杂度就是进行了多少次常数操作。

**选择排序：**

第一次：寻址$N$次，比较$N$次，$1$次交换

第二次：寻址$N-1$次，比较$N-1$次，$1$次交换

第三次：寻址$N-2$次，比较$N-2$次，$1$次交换

总共看了$$N+N-1+N-2+....+1$$，比较了$N+N-1+N-2+....+1$，交换了$N$次

总共操作了$aN^2+bN+C$，我们省略系数，取最高次，因此时间复杂度就是$O(N^2)$, $O$其实就是上限的意思，读作bigO，为什么是$O(N^2)$呢，这是因为大数据量的时候，瓶颈在$N^2$上。

###### 如果两个算法都是$O(N)$的时间复杂度，那么怎么去比较算法的好坏？

比较这两个算法的常数项，比如第一个算法常数项需要10次乘法运算，第二个算法需要20次加法运算，但是显然第二个算法运行更快。但是这样，比如一个算法有很多乘法，很多加法运算，位运算，这样就很难进行去理论计算了，所以还是实测来跑一下两个算法，看一下算法的运行时间，这样进行比较。因为都到常数项的地步了，就不用再进行理论分析了。。

还有两个符号， $O()$代表最差情况， $\theta()$代表平均情况，$\Omega()$代表最好情况

##### 空间复杂度

和时间复杂度类似，只不过是需要多少存储空间。



## 二、异或操作

##### 2-1,  快速交换

实际别这么整。

```c
a   = 10010
b   = 00111
a^b = 10001 
// 异或运算也可以理解为无进位相加，用这个理解最方便。
(1) 0^N=N  N^N=0
(2) 满足交换律和结合律  a^b=b^a  (a^b^c = a^(b^c))
(3) 一批数的异或，和运算顺序无关。
```

交换$a, b$， 

```C
a = a^b;
b = a^b;
a = a^b;
```

假设

```C
a = 甲
b = 已
a = a^b   a = 甲^已
b = a^b   b = 甲^已^已 = 甲^0 = 甲
a = a^b   a = 甲^已^甲 = 0^已 = 已
交换后   
a = 已  b = 甲
```

这样可以不用申请额外空间。 但是保证，a和b不能是同一块内存空间，否则就会将当前地址的值抹零，实际交换的时候别这么整。

##### 2-2，异或对应的题目

(1) 给你一个数组，只有一个数出现了奇数次，另外的数都出现了偶数次：

全部异或，最后得到的结果，就是答案

(2) 两个数出现了奇数次，其他的数都出现了奇数次。

a, b，偶数次  a!=b

准备一个变量叫eor ，全部异或一遍，那么eor = a^b;     那么eor != 0,  那么eor在某一位上不为0。 假设eor的bit7为1， 说明a和b在bit7上肯定不一样。其实肯定不肯全部都是0的，或者说异或结果有好几个bit不为0，随便选一个bit就可以。那么就取最右侧的1就可以。

在准备一个变量, eor’  , 让eor异或哪些bit7不是1的数。 那么eor’ 就等于a 或者 b了。  

<img src="Image/image-20250410092412330.png" alt="image-20250410092412330" style="zoom:33%;" />

other1肯定都是偶数个相同的， other2肯定也都是偶数个的。



## 3，插入排序

### **1. 核心步骤**

1. **划分区间**：将数组分为**已排序区间**（初始仅含第一个元素）和**未排序区间**。
2. **逐个插入**：从未排序区间取第一个元素，与已排序区间的元素**从后向前比较**，找到合适位置插入。
3. **重复操作**：直到未排序区间为空，排序完成。

### **3. 时间复杂度**

- **最好情况**（数组已有序）：只需比较 `n-1` 次 → O(n)。
- **最坏情况**（数组完全逆序）：需$\frac{n(n-1)}{2}$
- **平均情况**：$O(n^2)$。

```C
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) { // 从第2个元素开始（i=1）
        int key = arr[i];         // 待插入元素
        int j = i - 1;
        // 从后向前比较，移动比key大的元素
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key; // 插入到正确位置
    }
}
```

和冒泡排序，选择排序不同的是， 插入排序的时间复杂度和数据状况有关，而冒泡排序和选择排序和数据状况无关。

插入排序两个极端情况

```C
 1 2 3 4 5 6 7   O(n^2)
 7 6 5 4 3 2 1   O(n)
```

算法复杂度都是按照最差情况来估计，所以插入排序也是$O(n^2)$



## 4，二分查找

在有序数组找某个数。一般的方法是O(N)，但是二分法可以达到$O(log_2N)$

```C
int binarySearch(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2; // 防止溢出
        if (arr[mid] == target) {
            return mid; // 找到目标
        } else if (arr[mid] < target) {
            left = mid + 1; // 搜索右半部分
        } else {
            right = mid - 1; // 搜索左半部分
        }
    }
    return -1; // 未找到
}
```

1. ![image-20250410100116654](Image/image-20250410100116654.png)

可以灵活变通一下。主要是有二分的思想就很可以。

## 5，对数器

对数器（对数器、对数工具，英文常称为 **"Testing Harness"** 或 **"Verification Tool"**）是算法开发和测试中常用的一种工具，主要用于**验证算法正确性**和**生成测试数据**。其核心思想是通过随机生成大量测试用例，将待测试的算法与一个已知正确的“基准算法”对比结果，从而快速发现算法中的潜在问题。

要对 方法a 进行测试。

不追求时间复杂度， 很好想，很好写的算法， 是方法b

使用随机样本产生器，在方法a进行测试，在方法b进行测试，如果方法a和方法b结果一样，那就说明方法a和方法b是一致的。 

怎么产生随机数呢？









# 附录

##### 1-1, 选择排序

选择排序的每一轮操作分为两步：

1. **扫描未排序部分**，找到最小（或最大）元素；
2. **将该元素与未排序部分的第一个元素交换**，将其归入已排序部分。

重复上述过程，直到所有元素有序。

![image-20250410085516000](Image/image-20250410085516000.png)

##### 1-2, 冒泡排序

每一轮遍历数组，依次比较相邻的两个元素：

- 若顺序不符合要求（例如升序时前一个元素大于后一个元素），则交换它们；
- 每轮结束后，当前未排序部分的**最大元素会被“冒泡”到正确的位置**。

![image-20250410085436172](Image/image-20250410085436172.png)

每次，都是最大值，冒泡到正确的位置。

##### 2-1，提取出某个数最右侧的1

```
int rightOne = eor &(~eor + 1);
eor           = 1 0 1 0 1 1 1 1 0 0
~eor          = 0 1 0 1 0 0 0 0 1 1 
~eor+1        = 0 1 0 1 0 0 0 1 0 0 
eor & (~eor+1)= 0 0 0 0 0 0 0 1 0 0 
```

还真是，因为取反会将原来的0变为1，然后加1就会导致进位。